# This file lays out custom logging logic
# setup_logger gives us a namespaced logger specific to this package
# which can be controlled in isolation from other loggers and sets sensible
# defaults with respect to rotating log messages. Package version and R version also
# kept by default.
# with_log_handle allows us to wrap any expression with some default logging
# behaviour that captures warnings (and continues execution), errors and success with
# the expression trapped for narrowing down debugging or fixes.
# layout_json_custom allows us to properly format an arbitrary number of objects
# as a json log entry

#' Set up default logger
#'
#' Creates a rotating file log using json format, see
#' \link[logger]{appender_file} for details.
#'
#' @param dir directory path for logs
#' @export
setup_logger = function(dir = "./diagramAPI_logs") {
  if (! dir.exists(dir)) dir.create(dir)
  f = normalizePath(path.expand(file.path(dir, "log")))
  logger::log_formatter(logger::formatter_json)
  logger::log_layout(layout_json_custom(
    fields = c(
    "time", "level", "ns", "ns_pkg_version", "r_version"
  )))
  logger::log_appender(logger::appender_tee(f, max_lines = 2000L, max_files = 20L))
}

# parses message objects that are generated by
# warning() or stop()
# Regex extracts error/warning after Error:
# e.g Error: non-numeric gives "non-numeric"
parse_exception = function(msg) {
  stringr::str_match(as.character(msg), ".*: (.*)")[1, 2]
}

# generic log handler for capturing an expression
# and it's status
with_log_handle = function(expr) {
  expr_text = rlang::expr_text(rlang::enexpr(expr))
    res = withCallingHandlers(
      expr,
      error = function(e) {
        error_text = parse_exception(e)
        logger::log_error(expr = expr_text, error = error_text)
        e
      },
      warning = function(w) {
        warning_text = parse_exception(w)
        logger::log_warn(expr = expr_text, warning = warning_text)
        invokeRestart("muffleWarning")
      }
    )
  if (!inherits(res, "error")) {
    logger::log_success(expr = expr_text, result = res)
  }
  res
}

# allow arbitrary objects to be passed through to the logger
# this function is based on the logger::layout_json function
# see https://daroczig.github.io/logger/articles/customize_logger.html
layout_json_custom = function(fields = c("time")) {
    force(fields)
    # structure to match the logger documented requirements
    # for custom layout functions
    structure(
      function(
        level, msg, namespace = NA_character_,
        .logcall = sys.call(), .topcall = sys.call(-1),
        .topenv = parent.frame()
      ) {
        json = logger::get_logger_meta_variables(
          log_level = level, namespace = namespace,
          .logcall = .logcall, .topcall = .topcall,
          .topenv = .topenv
        )
        data = jsonlite::fromJSON(msg)
        sapply(
          msg, function(msg) {
            jsonlite::toJSON(c(json[fields], data), auto_unbox = TRUE)
          }
        )
    }, generator = deparse(match.call()))
}
