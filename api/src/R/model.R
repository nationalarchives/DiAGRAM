#' Load default model
#'
#' Load the default .bif model that should seed model scoring
#' This file was generated by the original authors.
#'
#' @return object of class bn.fit
#' @export
load_default_model = function() {
  fname = system.file("extdata", "model", "model.bif", package = "diagramAPI", mustWork = TRUE)
  bnlearn::read.bif(fname)
}

#' Score model
#'
#' Main entry point for scoring a model to be called by
#' the exposed API /score_model function. Should function
#' appropriately for both simple and advanced responses
#' (as indicated by the class attribute of responses parameter).
#' Will call necessary preprocessing on the responses and model
#' before returning a score.
#'
#' @param responses a parsed set of responses
#' @param model a network model, likely of class bn.fit
score_model_ = function(responses, model) {
  x = numeric_to_probability(to_numeric(responses))
  for (node in names(x)) {
    model[[node]] = x[[node]]
  }
  nodes = model_to_json(model)
  model = ensure_grain_model(model)
  query_results = gRain::querygrain(
    model,
    nodes = c("Intellectual_Control", "Renderability")
  )
  prob_intellectual_control = as.numeric(query_results$Intellectual_Control["Yes"])
  prob_renderability = as.numeric(query_results$Renderability["Yes"])
  utility = list(
    "intellectual_control" = 100 * prob_intellectual_control,
    "renderability" = 100 * prob_renderability,
    "nodes" = nodes
  )
  return(utility)
}

#' Ensure grain model
#'
#' Ensure that model has type grain required for
#' calculating score using the gRain library.
#'
#' @param model model object, likely of class bn.fit
#' @return model object of class grain
ensure_grain_model = function(model) {
  if (!is_grain(model)) {
    model = bnlearn::as.grain(model)
  }
  model
}

is_grain = function(model) {
  inherits(model, "grain")
}

single_node_to_json = function(node, node_name) {
  prob = as.data.frame(node$prob)
  pivot_name = if (node_name %in% .reverse_user_node_map) "Var1" else node_name
  df = tidyr::pivot_wider(prob, names_from = tidyselect::all_of(pivot_name), values_from = "Freq")
  unclass(df)
}

# Convert node information to the same
# json format that would be recieved from the advanced
# model format
model_to_json = function(model) {
  purrr::imap(model, single_node_to_json)
}
