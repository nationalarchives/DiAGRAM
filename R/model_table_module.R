#' model table module ui
#'
#' module ui container for the table that displays model information
#'
#' @param id A unique identifier for the module required by all shiny modules
#' @return a shiny taglist object
#' @export
model_table_module_ui = function(id) {
  ns = shiny::NS(id)
  shiny::tagList(
    DT::dataTableOutput(ns("table"))
  )
}

#' format model table
#'
#' Ensures formatting across model table displays is consistent and calculates each models scores
#'
#' @param intermediate an intermediate set of unformatted model/scenario data (tibble)
#' @param model the underlying bayesian network model to produce the scores, the actual values of the probabilities
#' internal to this model should in theory be irrelevant as they will be replaced with the values
#' generated by the set of responses for a given model/scenario set by the user
#' @param scoring_funcs a named list of scoring functions to apply to the responses in order to convert
#' them to probabilities
#' @param show_policy logical, should the policies be included in the formatted data
#' @return a tibble with models, comments and scores
format_model_table = function(intermediate, model, scoring_funcs, show_policy) {
  intermediate = tryCatch({
    dplyr::bind_cols(intermediate, purrr::map_dfr(intermediate$response, ~{
      score_model(model, format_responses(.x), scoring_funcs) %>% unlist
    }))
  }, error = function(e) browser())
  if(show_policy) {
    res = intermediate %>%
      dplyr::select(.data$model, .data$policy, "Intellectual Control" = .data$Intellectual_Control, .data$Renderability, .data$notes, .data$response)
  }else{
    res = intermediate %>%
      dplyr::filter(is.na(.data$policy)) %>%
      dplyr::select(.data$model, "Intellectual Control" = .data$Intellectual_Control, .data$Renderability, .data$notes, .data$response)
  }
  res %>%
    #dplyr::rename(Scenario=policy) %>%
    dplyr::rename_with(stringr::str_to_title) %>%
    dplyr::mutate_if(is.numeric, ~ round(.x, 2))
}


#' model table module server
#'
#' Server side logic for dealing with events associated with the table displays of
#' model and policy data.
#'
#' @importFrom rlang .data
#' @param input necessary input arg for shiny server function
#' @param output necessary output arg for shiny server function
#' @param session necessary session arg for shiny server function
#' @param data A reactive object that results in a data.frame/tibble, used to pass updates into the table
#' @param model The underlying bayesian network model, used for updating scores for model data
#' @param scoring_funcs A named list of scoring functions to translate user responses to probabilities
#' @param selection character, one of "multiple", "single", "none", how many items in the table should be allowed to be selected
#' @param show_policy logical, whether or not the scenarios should also be shown
#' @param pre_selected logical, if TRUE, pre-select the rows of the table
#' @param editable logical, can the names/comments be edited in the table
#' @param response_show logical, if TRUE allow the responses to a model be shown in a modal pop up on click of a button
#' within the table
#' @param question_data A list of the question data, for joining to responses in the modal pop up when showing responses
#' @return A list of reactive objects to pass events back to the parent see details
#' @details
#' The returned object is a collection of reactive objects
#' \itemize{
#'   \item selected - a reactive wrapper of a vector of integers, the rows of the table currently selected
#'   \item data - a reactive wrapper for the contents of names/comments in the table to allow edits to be maintained
#'   across all tabs.
#' }
#' @export
model_table_module_server = function(
  input, output, session,
  data, model, scoring_funcs,
  selection = "multiple", show_policy = TRUE,
  pre_selected = selection == "multiple",
  editable = TRUE, response_show = TRUE,
  question_data) {
  select_opts = list(
    mode = selection
  )
  # set up server side namespacing
  ns = session$ns

  # wrapper for returned data as a reactive
  data_src = shiny::reactiveVal(NULL)
  shiny::observeEvent(data(), {
    data_src(data())
  })
  table_contents = reactiveVal(NULL)

  shiny::observeEvent(data_src(), {
    print("data change")
    df = data_src()
    if(nrow(df) == 0){
      table_contents(DT::datatable(NULL))
      return()
    }
    if(pre_selected & selection == "multiple"){
      select_opts$selected = seq_len(nrow(df))
    }
    df = format_model_table(df, model, scoring_funcs, TRUE)
    print(df)
    if(!show_policy) {
      df = dplyr::filter(df, is.na(.data$Policy))
    }
    df = df %>% dplyr::mutate_if(is.numeric, ~{.x*100})
    if(editable){
      df = add_delete_column(df, ns)
      df = add_edit_column(df, ns)
    }
    if(response_show){
      df = add_show_column(df, ns)
    }
    tab = DT::datatable(
      dplyr::select(
        df, .data$Edit, .data$Delete,
        tidyr::everything(), -.data$Response,
        Response = .data$Show
      ),
      extensions = 'RowGroup',
      selection = select_opts,
      escape = FALSE,
      editable = list(target = "cell", disable = list(columns = c(1,4,5,7))),
      options = list(
        rowGroup = list(dataSrc = 3),
        preDrawCallback = DT::JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
        drawCallback = DT::JS('function() { Shiny.bindAll(this.api().table().node()); } ')
      )
    ) %>%
      # inline table bar charts
      DT::formatStyle(
        'Renderability',
        background = DT::styleColorBar(c(0,100), '#8400CD'),
        backgroundSize = '100% 90%',
        backgroundRepeat = 'no-repeat',
        backgroundPosition = 'center',
        color = 'white'
      ) %>%
      DT::formatStyle(
        'Intellectual Control',
        background = DT::styleColorBar(c(0,100), '#FF6E3A'),
        backgroundSize = '100% 90%',
        backgroundRepeat = 'no-repeat',
        backgroundPosition = 'center',
        color = 'black'
      ) %>%
      DT::formatStyle(
        "Model",
        target = 'row',
        fontStyle = DT::styleEqual("Ref: Commercial Backup",'italic'),
        backgroundColor = DT::styleEqual("Ref: Commercial Backup",'#F9F7E2')
      )
    # to_delete(numeric(0))
    table_contents(tab)
  })

  output$table = DT::renderDataTable({
    print("draw table")
    table_contents()
  })

  # event that a user clicks edit in the table
  observeEvent(input$editPressed, {
    print("edit press")
    ix = parse_column_event(input$editPressed)
    df = data_src()
    row = df[ix, ]
    model_name = row$model
    policy_name = row$policy
    notes = row$notes
    modal = createModal(ns, model_name, policy_name, notes)
    showModal(modal)
  })

  # event that a user cancels input in the editing modal
  observeEvent(input$modal_cancel, {
    removeModal()
  })

  # event to submit responses in the editing modal
  observeEvent(input$modal_submit, {
    will_close = TRUE
    ix = parse_column_event(input$editPressed)
    df = data_src()
    model_name = input$modal_model
    is_baseline = is.na(df[ix,]$policy)
    policy = input$modal_policy # if non existent = NULL, if empty
    comment = input$modal_comment # if placeholder = ''
    if(is_baseline){ # update all those with the same name
      if(!is.null(model_name) && model_name != ''){
        df[df$model == df[ix,]$model, ]$model = model_name
      }else{
        will_close = FALSE
      }

    }else {
      # check that policy is not empty
      if(!is.null(policy) && policy == ''){
        will_close = FALSE
      }else{
        df[ix,]$policy = policy
      }
    }
    if(comment == '') {
      comment = NA
    }
    df[ix,]$notes = comment

    if(will_close) {
      removeModal()
      data_src(df)
    }
  })

  # event to show responses from click event in table
  show_modal_data = reactiveVal(NULL)
  observeEvent(input$showPressed, {
    ix = parse_column_event(input$showPressed)
    df = data_src()
    row = df[ix,]
    print(row)
    to_show = row %>%
      format_model_table(model, scoring_funcs, TRUE) %>%
      format_data_for_download(question_data)
    print(to_show)
    # print()
    show_modal_data(to_show)
    modal = create_data_modal(ns, to_show)
    showModal(modal)
  })

  # close the response show modal
  shiny::observeEvent(
    input$data_modal_cancel,{
      removeModal()
    }
  )
  # render the table to show in the response modal
  output$modal_table = DT::renderDataTable({
    DT::datatable(dplyr::select(show_modal_data(), .data$Question:.data$Response))
  })

  # listen to a user clicking delete in the table
  observeEvent(input$deletePressed, {
    print("delete pressed")
    ix = parse_column_event(input$deletePressed)
    df = data_src()
    df = df[-ix,]
    data_src(df)
  })

  selected = shiny::reactive({
    print("change selection")
    input$table_rows_selected
  })

  return(list(selected = selected, data = data_src))
}


table_bar_chart = function(
  label, width = "100%", height = "16px",
  fill = "#00bfc4", background = NULL
) {
  bar = shiny::div(
    style = list(
      background = fill,
      width = width,
      height = height
    )
  )
  chart = shiny::div(
    style = list(
      flexGrow = 1,
      marginLeft = "8px",
      background = background
    ), bar
  )
  shiny::div(style = list(display = "flex", alignItems = "center"), label, chart)
}



## extra utility funcs for adding events to the tables

#' add delete column
#'
#' Add a column with a delete button to a tibble, attaching a namespaced shiny input event
#' for listening to the click
#'
#' @param df original tibble to add a delete column to
#' @param ns shiny namespace object
#' @param ... currently unused, additional arguments passed on to internal methods
#' @return a tibble
add_delete_column = function(df, ns, ...){
  f = function(i) {
    as.character(
      shiny::actionButton(
        # The id prefix with index
        paste(ns("delete"), i, sep="_"),
        label = "Delete",
        icon = icon('trash'),
        onclick = glue::glue('Shiny.setInputValue(\"{ns("deletePressed")}\", this.id, {{priority: "event"}})')
      )
    )
  }

  deleteCol = unlist(lapply(seq_len(nrow(df)), f))
  dplyr::bind_cols(df, Delete = deleteCol)
}

#' add show column
#'
#' Add a column with a show button to a tibble, attaching a namespaced shiny input event
#' for listening to the click
#'
#' @param df original tibble to add a show column to
#' @param ns shiny namespace object
#' @param ... currently unused, additional arguments passed on to internal methods
#' @return a tibble
add_show_column = function(df, ns, ...) {
  f = function(i) {
    as.character(
      shiny::actionButton(
        # The id prefix with index
        paste(ns("show"), i, sep="_"),
        label = "Show",
        # icon = icon('trash'),
        onclick = glue::glue('Shiny.setInputValue(\"{ns("showPressed")}\", this.id, {{priority: "event"}})')
      )
    )
  }
  showCol = unlist(lapply(seq_len(nrow(df)), f))
  dplyr::bind_cols(df, Show = showCol)
}

#' add edit column
#'
#' Add a column with an edit button to a tibble, attaching a namespaced shiny input event
#' for listening to the click
#'
#' @param df original tibble to add an edit column to
#' @param ns shiny namespace object
#' @param ... currently unused, additional arguments passed on to internal methods
#' @return a tibble
add_edit_column = function(df, ns, ...) {
  f = function(i) {
    as.character(
      shiny::actionButton(
        # The id prefix with index
        paste(ns("edit"), i, sep="_"),
        label = "Edit",
        icon = shiny::icon('edit'),
        onclick = glue::glue('Shiny.setInputValue(\"{ns("editPressed")}\", this.id, {{priority: "event"}})')
      )
    )
  }

  editCol = unlist(lapply(seq_len(nrow(df)), f))
  dplyr::bind_cols(df, Edit = editCol)
}

#' parse column event
#'
#' A function to help deal with the many edit, show and delete buttons added
#' into the tables of the model view. Parses the string and matches the corresponding number.
#'
#' @param idstr An id string, typically sent with a shiny click event
#' @return an integer corresponding to which button has been clicked
parse_column_event = function(idstr) {
  res = as.integer(sub(".*_([0-9]+)", "\\1", idstr))
  if (! is.na(res)) res
}

#' create data modal
#'
#' Create the modal object that contains the shown responses for
#' a selected model
#'
#' @param ns a shiny namespace object
#' @param data The data that will be shown, only used to determine whether this
#' is a custom model or not as at this time custom model responses can not be shown
#' sensibly
#' @return a shiny taglist object
create_data_modal = function(ns, data) {
  is_custom = unique(data$`Custom Model`)
  if(!is_custom) {
    el = DT::dataTableOutput(ns('modal_table'))
  }else{
    el = div("Data from custom models can not be shown.")
  }
  shiny::modalDialog(
    title = "View",
    el,
    footer = shiny::tagList(
      shiny::actionButton(ns("data_modal_cancel"), "Close"),
    )
  )
}

#' createModal
#'
#' Create the modal dialogue box for editing names and comments of models/scenarios
#'
#' @param ns a shiny namespace object
#' @param model the model name of the selected model
#' @param policy the scenario name of the selected scenario
#' @param comment the current comment string that is attributed to the
#' selected model/scenario
#' @return a shiny taglist object
createModal = function(ns, model, policy, comment) {
  model_element = if(!is.na(policy)) {
    NULL
  } else {
    shiny::textInput(ns("modal_model"), "Model Name", value = model, placeholder = "This model must have a name")
  }
  policy_element = if(!is.na(policy)) {
    shiny::textInput(ns("modal_policy"), "Scenario Name", value = policy, placeholder = "This scenario must have a name.")
  }else{
    NULL
  }
  comment_element = if(!is.na(comment)) {
    shiny::textAreaInput(ns("modal_comment"), "Comments", value = comment)
  }else {
    shiny::textAreaInput(ns("modal_comment"), "Comments", placeholder = "You could add some comments here.")
  }
  shiny::modalDialog(
    title = "Edit",
    tagList(
      model_element,
      policy_element,
      comment_element
    ),
    footer = tagList(
      shiny::actionButton(ns("modal_cancel"), "Cancel"),
      shiny::actionButton(ns("modal_submit"), "Submit")
    )
  )
}
